{"version":3,"file":"resolution.js","sourceRoot":"","sources":["../../src/dependencies/resolution.ts"],"names":[],"mappings":"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","sourcesContent":["import Module from 'node:module';\n\nimport {\n  type ResolutionResult,\n  type DependencyResolution,\n  DependencyResolutionSource,\n} from './types';\nimport {\n  type PackageJson,\n  defaultShouldIncludeDependency,\n  mergeWithDuplicate,\n  loadPackageJson,\n  maybeRealpath,\n  fastJoin,\n} from './utils';\n\ndeclare module 'node:module' {\n  export function _nodeModulePaths(base: string): readonly string[];\n}\n\n// NOTE(@kitten): There's no need to search very deep for modules\n// We don't expect native modules to be excessively nested in the dependency tree\nconst MAX_DEPTH = 8;\n\nconst createNodeModulePathsCreator = () => {\n  const _nodeModulePathCache = new Map<string, string | null>();\n  return async function getNodeModulePaths(packagePath: string) {\n    const nodeModulePaths = await Promise.all(\n      Module._nodeModulePaths(packagePath).map(async (nodeModulePath, idx) => {\n        let target = _nodeModulePathCache.get(nodeModulePath);\n        if (target === undefined) {\n          target = await maybeRealpath(nodeModulePath);\n          if (idx !== 0) {\n            _nodeModulePathCache.set(nodeModulePath, target);\n          }\n        }\n        return target;\n      })\n    );\n    return nodeModulePaths.filter((nodeModulePath) => nodeModulePath != null);\n  };\n};\n\nasync function resolveDependencies(\n  packageJson: PackageJson,\n  nodeModulePaths: readonly string[],\n  depth: number,\n  shouldIncludeDependency: (dependencyName: string) => boolean\n): Promise<DependencyResolution[]> {\n  const dependencies =\n    packageJson.dependencies != null && typeof packageJson.dependencies === 'object'\n      ? packageJson.dependencies\n      : {};\n\n  const dependencyNames: string[] = [];\n  for (const dependencyName in dependencies) {\n    if (shouldIncludeDependency(dependencyName)) {\n      dependencyNames.push(dependencyName);\n    }\n  }\n\n  if (packageJson.peerDependencies != null && typeof packageJson.peerDependencies === 'object') {\n    const peerDependenciesMeta =\n      packageJson.peerDependenciesMeta != null &&\n      typeof packageJson.peerDependenciesMeta === 'object'\n        ? (packageJson.peerDependenciesMeta as Record<string, unknown>)\n        : undefined;\n    for (const dependencyName in packageJson.peerDependencies) {\n      if (dependencyName in dependencies || !shouldIncludeDependency(dependencyName)) {\n        continue;\n      } else if (isOptionalPeerDependencyMeta(peerDependenciesMeta, dependencyName)) {\n        // NOTE(@kitten): We only check peer dependencies because some package managers auto-install them\n        // which would mean they'd have no reference in any dependencies. However, optional peer dependencies\n        // don't auto-install and we can skip them\n        continue;\n      } else {\n        dependencyNames.push(dependencyName);\n      }\n    }\n  }\n\n  const modules = await Promise.all(\n    dependencyNames.map(async (dependencyName): Promise<DependencyResolution | null> => {\n      for (let idx = 0; idx < nodeModulePaths.length; idx++) {\n        const originPath = fastJoin(nodeModulePaths[idx], dependencyName);\n        const nodeModulePath = await maybeRealpath(originPath);\n        if (nodeModulePath != null) {\n          return {\n            source: DependencyResolutionSource.RECURSIVE_RESOLUTION,\n            name: dependencyName,\n            version: '',\n            path: nodeModulePath,\n            originPath,\n            duplicates: null,\n            depth,\n          };\n        }\n      }\n      return null;\n    })\n  );\n\n  return modules.filter((moduleEntry) => moduleEntry != null);\n}\n\ninterface ResolutionOptions {\n  shouldIncludeDependency?(name: string): boolean;\n  limitDepth?: number;\n}\n\nexport async function scanDependenciesRecursively(\n  rawPath: string,\n  { shouldIncludeDependency = defaultShouldIncludeDependency, limitDepth }: ResolutionOptions = {}\n): Promise<ResolutionResult> {\n  const _visitedPackagePaths = new Set();\n  const getNodeModulePaths = createNodeModulePathsCreator();\n  const maxDepth = limitDepth != null ? limitDepth : MAX_DEPTH;\n  const searchResults: ResolutionResult = Object.create(null);\n\n  const recurseDependencies = async (parent: DependencyResolution): Promise<void> => {\n    const nodeModulePaths = await getNodeModulePaths(parent.path);\n    const packageJson = await loadPackageJson(fastJoin(parent.path, 'package.json'));\n    if (!packageJson) {\n      return;\n    }\n    parent.version = packageJson.version || '';\n    const depth = parent.depth + 1;\n    if (depth >= maxDepth) {\n      return;\n    }\n    const resolutions = await resolveDependencies(\n      packageJson,\n      nodeModulePaths,\n      depth,\n      shouldIncludeDependency\n    );\n    const tasks: Promise<void>[] = [];\n    for (let idx = 0; idx < resolutions.length; idx++) {\n      const resolution = resolutions[idx];\n      if (!_visitedPackagePaths.has(resolution.path)) {\n        _visitedPackagePaths.add(resolution.path);\n        const prevEntry = searchResults[resolution.name];\n        if (prevEntry != null && resolution.path !== prevEntry.path) {\n          searchResults[resolution.name] = mergeWithDuplicate(prevEntry, resolution);\n        } else if (prevEntry == null) {\n          searchResults[resolution.name] = resolution;\n        }\n        tasks.push(recurseDependencies(resolution));\n      }\n    }\n    await Promise.all(tasks);\n  };\n\n  const rootPath = await maybeRealpath(rawPath);\n  if (rootPath) {\n    await recurseDependencies({\n      source: DependencyResolutionSource.RECURSIVE_RESOLUTION,\n      name: '',\n      version: '',\n      path: rootPath,\n      originPath: rawPath,\n      duplicates: null,\n      depth: -1,\n    });\n  }\n\n  return searchResults;\n}\n\nconst isOptionalPeerDependencyMeta = (\n  peerDependenciesMeta: Record<string, unknown> | undefined,\n  packageName: string\n) => {\n  return (\n    peerDependenciesMeta &&\n    peerDependenciesMeta[packageName] != null &&\n    typeof peerDependenciesMeta[packageName] === 'object' &&\n    'optional' in peerDependenciesMeta[packageName] &&\n    !!peerDependenciesMeta[packageName].optional\n  );\n};\n"]}